<h1>On Becoming a Programmer</h1>
<p>2019-06-20</p>

<p>This essay is <a href="https://www.facebook.com/michael.karpeles/posts/10103765340214890?comment_id=10103765762418790&reply_comment_id=10103765978331100&comment_tracking=%7B%22tn%22%3A%22R%22%7D">a response to</a>, "How does one Project Manage?"
</p>

<ul>
<li>
Understand what a "project architecture" is at a conceptual (even before you know a thing about coding). Find the type of project you aspire to work on and find someone who (or some resource which) can walk you through the components at a high level. E.g. for a web-service, at a high level, what's happening is a user interfaces with a computer program called a web browser which is specialized utility which make requests for/with data on your behalf to other computers, and gives you a visual medium (guided by a set of rules you can learn) to render the results as what you know is a webpage. There are three key elements in this process (a) the "networking"; i.e. the actual request being transferred (the data format/protocol and how these packets of data make it to the correct destination, (b) the architecture of the "service" responsible for interpreting the packets sent by your browser and crafting the response back to your browser, and (c) the process by which your browser interprets the response of the "service" and renders it (stylistically, interactively, semantically) to you as a user. For (a) you may expect to encounter terms such as HTTP, TCP, IP, GET, POST, cookies, urls, DNS, and routing. For (b) for basic systems, you may expect to hear terms like "HTTP server" (e.g. nginx/apache/lighttpd), "search engine" (e.g. solr, lucene, elasticsearch), "cache" (e.g. memcached, redis, varnish), a "load balancer" (e.g. haproxy) which distributes the load of your very popular service across many computers, a database (e.g. postgres, mysql, mongodb, neo4j) which is a program optimized to store and retrieve large volumes of data, a "web application" (the heart of the system you program/define to accomplish (b) which can be done in your choice of programming languages, often each language having its own frameworks and software packages you can leverage to facilitate development, and each likely having tried-and-true getting started tutorials online). You may find other component come up in more complex systems, especially around data processing, machine learning models, analytics, using time-sequence data, but this is left as an exercise to the reader to discover. And (c) comes with more fun acronyms, like HTML, CSS, JS, json, xml, rdf, fonts, svg.
</li>

<li>
Choose a programming language to dabble in. Note that the language you choose will confer certain advantages / tradeoffs. Some are conceptually more challenging to get started with because (I'll say it) they were built to solve hard problems. Like erlang and concurrency. If you start with Haskell or erlang or C++ as your first language, expect there to be a learning curve (even if it pays dividends long-term to start here) and know-thyself re: whether you are the type of person who has the constitution to survive the process of understanding how the car works before you can drive it. Python and Ruby are often easier languages to get started with (their syntax for writing instructions is arguably more intuitively human readable as an objective and they both have a large communities who build plugins you can leverage to achieve common tasks, e.g. you don't have to write an integral function, one exists). At the same time (not always, but a heuristic is) languages that seem trivially easy and convenient to use are likely to have performance hits over other languages. The more necessary pain we're willing to endure + the more we are able to bend our code to be explicit (and unambiguous -- less interpretation requires) and make sense to computers (without convoluting the code we're trying to write and making it harder for other programmers), the more likely the code is to perform well for the specific cases it needs to, and as expected. Choosing a language is an art and somewhat problem specific. Are you learning a language to get something working? Because you want a deep understanding of what paradigms and features exist (e.g. because you want to become elite and create better tools yourself, not just get a job or product-program as a hobby)? Specifically for this task (of getting started with a language), a getting started guide online, a coursera class or youtube equivalent set of tutorials, a code bookcamp, or a book / online walkthrough are likely enough to introduce you to the core concepts of programming, to the language itself, and how to setup your computer's environment to write your first "hello world" (the first minimal canonical program most programmers write in a language to get the application built and running).
</li>

<li>
The application-specific task. At this point, the foundations are in place to begin creating a project. This is where you'll need to deep dive into the frameworks and tools available within a language and understand how the components of your architecture communicate. Python has a web framework called flask which can get you up-and-started without needing to know the majority of components listed in (1) above (e.g. disregard web server, search engine, database, cache, load balancing, etc). Assuming you've gone through (2) and understand the fundamentals, getting a minimal web-service up and running can likely be achieved in around 10 lines of python flask code (each line which will probably mystify you and be completely incomprehensible to debug if you've copied something wrong or have a missing dependency).
This also likely includes revisiting (1.c) to the extent you want to understand the "front-end" aspects of software engineering. i.e. the role of HTML as producing the semantic markup that the browser renders, the role of js providing interactivity to elements and the user experience (including fetching and sending data in realtime without reloading the page), and CSS in providing style and position to elements without changing the semantics of the content (not conflating style and content is important both from a maintainability perspective, as it is for users with print disabilities to navigate your site, and search engines like google to effectively index your content). Each of these technologies (html, js, css) have their own frameworks for meeting the challenges larger projects face, like efforts to programmatically eliminate redundant code and minimize the size of the assets for performance, frameworks for managing complex interactive flows (e.g react), and frameworks for standardizing component styles (because most of us are not designers and do more harm than good).
</li>

<li>
The application-specific ecosystem. Provisioning. Deploying. Virtual-environments and containerization. Writing tests: unit & integration. Setting up continuous integration. Scaling. Industry practices e.g. version control. Exercise left to reader to painfully discover.
</li>

<li>
Research. Now's the time to revisit (2), to read Paul Graham's "Blub Paradox" section of "Beating the Averages" https://web.archive.org/...//www.paulgraham.com/avg.html and understand. About now, you've started to hit security problems. Or problems with concurrency and threading. Or hit expensive database queries. And each of the elements described in (2.b) are now apart of your stack. You start to hit the edge of what the industry offers off the shelf. Your AWS bill starts to get too expensive running 50 python web heads. And you decide to re-write in a new language. Or you specialize, writing specific algorithms, pursuing optimization, static analysis, security, front-end, dev-ops, or machine learning. Or decide you'd rather go the path of team-leading.
</li>

</ul>
