<pre>
akkartik [11:38 AM] 
My latest attempt at an elevator pitch (after conversations with Josh, Ben and Mek): I'm trying to eradicate bureaucracy in software. Bureaucracy defined as doing things without remembering why we're doing them.

​[11:39] 
Mu is just an experimental testbed.

btrask [11:39 AM] 
@akkartik: not trying to give you a hard time, but i'd say thats tradition, not bureaucracy

​[11:42] 
http://www.chesterton.org/taking-a-fence-down/
American Chesterton Society
Taking a Fence Down
Is it true John F. Kennedy quoted Chesterton as saying something about not taking a fence down until you know the reason why it was put it up?
April 29th, 2012 at 5:12 PM

​[11:42] 
but we've gone over this plenty :wink:

akkartik [11:49 AM] 
:)

​[11:50] 
Work in progress. Elevator pitches get some leeway I think.

​[11:51] 
I don't see the word 'tradition' anywhere there?

btrask [11:52 AM] 
well, there are multiple terms for things we do without remembering why, some positive some negative

​[11:53] 
common sense, instinct, muscle memory... cargo cult, the blind following the blind

​[11:54] 
tradition really captures it though, because there are some traditions that are good, and some that are terrible

​[11:55] 
i liked it when you called mu a teaching language, but i agree that doesn't really capture it

difranco [11:59 AM] 
In the programming world as well as the world at large I'd say there's too much blind imitation built into things. Chesterton should also apply to keeping fences up - you don't get off the hook on the decision either way until you understand what purpose it serves (or more commonly, doesn't anymore).

btrask [12:02 PM] 
when you're improving something, after it's already very good, it becomes overwhelmingly likely that any change will make things worse

​[12:02] 
its like trying to purify something that's already 99.999% pure, almost anything will increase contamination

​[12:03] 
of course, we can debate how "good" the world currently is

​[12:03] 
but in the long run, you will eventually need to be cautious about changes

​[12:05] 
...i'm probably the most conservative person here, not because i'm actually conservative, but because i see the value of moderation

​[12:06] 
if you make sloppy changes and make things worse, you're just giving ammo to the true conservatives who never want to change things ever

​[12:06] 
so please, be cautious :simple_smile:

btrask [12:17 PM] 
i feel like i've already burnt some political capital here by saying that...

akkartik [12:18 PM] 
Absolutely! I'm usually the one saying that in my circles :) Notice in our emails that I've said we need to make sure the new Caesar isn't just the same old Caesar in different garb. And about being careful what you wish for.

btrask [12:19 PM] 
yeah good point, thank you

akkartik [12:19 PM] 
Elsewhere I've said that I'm in support of change.. but veery carefully.

btrask [12:20 PM] 
and as merely experimental projects, things like mu or stronglink aren't exactly big risks

akkartik [12:21 PM] 
Scrolling backwards.. Yeah, teaching is a huge part of my road but not all of it. Weaving humanity off bureaucracy and division of labor can't be just an engineering project.

​[12:21] 
*Weaning

btrask [12:22 PM] 
ok this is honest confusion... what does a programming language have to do with bureaucracy and division of labor?

akkartik [12:23 PM] 
Without spending a lot of time arguing semantics, I prefer bureaucracy to tradition. Tradition isn't typically considered functional, more functional+. And you don't typically think of the patent office or IRS as a tradition. That's more on the spirit of what I'm trying to avoid in software.

btrask [12:25 PM] 
cargo cult?

akkartik [12:25 PM] 
I'm a big proponent of Chesterton's fence. But my reaction to it is that it's often the original builders' fault that nobody remembers what the fence is for.

btrask [12:25 PM] 
lol true

​[12:25] 
documentation!

akkartik [12:26 PM] 
Cargo cults never work. But bureaucracies continue to work. They just spend less and less effort on working as time passes..

btrask [12:26 PM] 
oh, i kind of see what you're getting at

​[12:27] 
the bureaucracy of software development, or programming...

difranco [12:27 PM] 
I categorically think fences should be tied to clear statements of their intended purposes, so that the question of speculating about them never arises, and that fences that aren't so labeled are obsolete.

btrask [12:28 PM] 
well that helps, but i'd say chesterton's fence doesn't go far enough, because even if the original intended purpose is invalid/obsolete, there can be secondary purposes that arose without conscious awareness

​[12:29] 
you have to fully "reverse engineer" the fence in order to really improve (remove) it

akkartik [12:30 PM] 
That's a good point. Out of scope for me, I think :/

btrask [12:32 PM] 
one example for programming languages is that languages with algol-style syntax seem to be more popular, but we don't really have any concrete reasons why (familiarity? easy to read?)(edited)

​[12:34] 
if your goal is popularity (of course it might not be), then you might want to follow the crowd even if there's no real reason for it(edited)

akkartik [12:34 PM] 
I don't particularly care about languages or what syntax they use. Most of our problems come from ​*codebases*​ being hard to understand (http://akkartik.name/about, in case somebody hadn't already seen it)

btrask [12:35 PM] 
it was just an example

akkartik [12:35 PM] 
Try another? :) Just doesn't seem like a big deal to me.

btrask [12:36 PM] 
something else that seems like a good idea, without really understanding why... i'll have to think about it

akkartik [12:36 PM] 
You don't need to persuade me though. I've certainly encountered the phenomenon in my own code, often in tiny codebases..

btrask [12:38 PM] 
this is another example you might not care about, but http://lkml.iu.edu/hypermail/linux/kernel/1510.3/02866.html

​[12:38] 
in theory overflow checking is better... in practice it's easy to break things by trying to fix them

akkartik [12:39 PM] 
Brb

akkartik [1:42 PM] 
Can you elaborate? If read that before, but even after a reread I don't see how it connects up with this conversation. Was there something the new code failed to reverse engineer?

​[1:43] 
*I'd read that

btrask [1:58 PM] 
@akkartik: it failed to reverse engineer... simplicity :wink:

akkartik [3:07 PM] 
:)

mek [4:46 PM] 
https://michaelkarpeles.com/essays/politics/kicking-the-bucket

​[4:47] 
I think fences are an important topic, but to me they are an unoptimal analog as I see a better mathematical parallel.

​[4:49] 
One of the big reasons for confusion (bureaucracy, not remembering) is, something has the quality of being ambiguous or convoluted. e.g. Something is implemented in a strange way because it achieves an optimization (approximates a solution from an awkward or unintuitive angle).(edited)

​[4:50] 
A different way of viewing this is, with respect to ​*comprehension*​, is that the implementation semantically over or underfits .(edited)

​[4:50] 
And what we're talking about is not a fence, but some sort of linear or logistic classifier, to which a fence is an analogy.

​[4:55] 
What I am getting at is, I think machine learning can and should be used to augment our programs -- both to help us craft more understandable code (to accommodate both semantics and performance), and that it should do so by (scoring) making us aware of the trade-offs, ultimately suggesting code improvements pre-commit (within the editor), and immediately producing auto/machine-generated documentation which justifies or explains these decisions. The reason this approach isn't commonly used is, it's really expensive.(edited)

​[4:56] 
A popular alternative is a type of ​*self-documenting*​ (if you'll permit me leeway) code, e.g. a lisp macro, which solves an unintuitive (perhaps) problem by appealing or aligning with ​*syntax*​ which denotes or suggests certain ​*semantics*​

​[4:58] 
To a degree, we're afforded a lot of clarity just be virtue of compilers being good at optimizing away complexity (though this shows the optimization could likely have been built into the language/grammar in the first place)

​[4:59] 
A good example of this is tail recursion, whereby many languages (compilers) offer methods for writing recursion in a way which doesn't pollute the stack.

​[4:59] 
When I say methods, I refer to a compiler trampolining results or offer native TCO (tail call optimization) to generate the iterative rough equivalent of the recursion at machine-level (asm).

​[5:01] 
That's the end of my rant, I'll turn it into an essay and throw it on my blog (and will continue editing it there) so I don't continue to ruin what was a good conversation :simple_smile:

​[5:02] 
I have exports of our slack channel, we should really find a way to prune these conversations into essays on specific topics (stronglink'd) @btrask
</pre>
