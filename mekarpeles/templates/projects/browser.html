<h1>Browser</h1>
<h2>An experimental emacs-like web browser</h2>

<p>Unix-like operating systems are great. *nix features wonderfully thought out file-systems complete with grand methods for traversing (navigating) file/folder hierarchies. This is great, but it isn't what makes *nix "great".</p>

<p>*nix have standards, transparency, and passionate active communities which results in fairly fast release schedules and general high quality maintenance standards. They can manifest as specialty distributions, attacking individual core concerns such as security, minimalism, scalability, and entertainment. This is great, but it isn't what makes *nix great</p>

<p>When people think of *nix, they may think Unix, or Linux. Or BSD or FreeBSD, or Solaris, or Darwin. They may even think of the kernel, insmod, block devices, of schedulers, of inittab, of systemv or systemd, or containers. These are all great things. They are great things specifically because their purpose is to enable great things.</p>

<p>When I think *nix, I think of man, curses, bash/zsh, irssi, mutt/pine, emacs/vim, tmux, diff, gcc, python, and GNU coreutils. I think of forks, PIPES. Good old fashioned anonymous pipes! The magical ability to employ those (analogical) futuristic US Post Vacuum tubes and beam parcels of data from one program to another, with nothing in your way to stop you. That is, I think of *nix, the philosophy. The philosophy which combines *nix and GNU. Which views every program as an interface which can be programmed, extended, modified, and in such spirit, combined with other programs for great glory!</p>

<p>That *nixes are extensible, flexible, customizable, and treat programmers as 1st-class citizens, awarding freedom and access to underlying systems and architecture. This is what makes *nix great. And it't not just that each program should be free (as in freedom) or open source, but that it's running instance offers an API or configuration layer (rc's, etc) affording arbitrary extensibility or accessibility to the "average programming/tinkering user" and not only core developers whose changes emerge in a build. I'm talking about bash.rc, about .emacs. This is what makes *nixes so great.</p>

<p>But web browsers, even the open source ones, are almost entirely lacking in this key philosophy.</p>

<p>In a web browser, we are constrained to a rudimentary "navigation" system (forward, back, history, cancel, url bar / "go" -- fortunately there are web services like google for actually finding content). We're limited to a minimal file system (tabs, bookmarks/favorites). Forget archiving resources in case they are taken offline. Forget marking a resource as "read later". Forget creating a directed graph of the resources you're visiting. Forget making collections of tabs (unless you're firefox and produce the worst, most unusable implementation of this feature I can possible conceive -- but hey, at least it's there). Browsers tend to focus on their core competencies: security and providing a fast and performant rasterization/rendering system for (html, jss, etc) web standards. And don't get me wrong, this is important, just like *nix is important. But what browsers need is GNU coreutils. It needs emacs/vim love. It needs pipes. And I'm not talking about "chrome extensions" (though there are some great extensions, e.g. vimium which may even be the exception which proves the following rule).</p>

<p>The biggest joke on us is, we have one of the most powerful languages for manipulating everything in the browser (ecmascript/javascript) at our disposal, except for manipulating the browser itself! Some browsers are trying to address this (e.g. http://conkeror.org/ -- emacs styled tiled windows in feature branch!) and I will be supporting them in whatever ways I can. What we need is the bash/emacs/vim of browsers -- e.g. coding changes to your browser (emacs style) without requiring recompiling and building. Intercommunication between these native extensions. And a package manager. The GNU of browsers. But first, the *nix of browsing must exist.</p>

<p>
<a href="">Drew</a>, <a href="">Josh Juran</a>, and I were discussing this and other related concepts, like how it would be nice if every HTTP resource had a "git"-like history preserved for it and a special/reserved GET param could be used in order to specifying the version hash of the specific instance of the resource you want (like wikipedia does with permalinks). e.g. cnn.com/stories/boy-wins-money?rcv=1AC89F71.</p>
